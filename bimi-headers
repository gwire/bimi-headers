#!/usr/bin/env python3

## PoC implementation of BIMI draft
##    https://www.ietf.org/archive/id/draft-brand-indicators-for-message-identification-05.html#name-receiver-actions
##
## TODO:
## - pem validation
## - svg validation

import sys
import logging
import argparse
import base64
import email
from email.header import Header
import textwrap
import hashlib
import gzip
import re
import requests
from importlib.metadata import version
from pathlib import Path

import dns.resolver
from publicsuffix2 import PublicSuffixList,get_public_suffix

parser = argparse.ArgumentParser(
        prog='bimi-headers',
        description='Generate BIMI email headers for a given domain',
        epilog='A successful pass result for DMARC is assumed.')
parser.add_argument("domain", help="The author domain")
parser.add_argument("--selector", help="The selector (default: default)", default="default")
parser.add_argument("--authserv-id", help="Authetication-Results authserv-id (default: mailserver.local)", default="mailserver.local")
parser.add_argument("--status-only", action='store_true', help="Only return the auth result", default=False)
parser.add_argument("--bimi-auth-only", action='store_true', help="Only return the unwrapped bimi content of Authentication-Results", default=False)
parser.add_argument("--indicator-only", action='store_true', help="Only return the content of BIMI-Indicator", default=False)
parser.add_argument("--location-only", action='store_true', help="Only return the content of BIMI-Location", default=False)
parser.add_argument("--wrap", help="Mail header wrap style (default: space)", choices=['space','tab','none'], default='space')
parser.add_argument("--cache-dir", help="File cache directory (default: /tmp)", default='/tmp')
parser.add_argument("--debug", action='store_true', help="Show debug", default=False)
args= parser.parse_args()

if args.debug:
    logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)


## https://stackoverflow.com/questions/11887762/how-do-i-compare-version-numbers-in-python
def versiontuple(v):
    return tuple(map(int, (v.split("."))))

def get_org_domain(domain):
    psl = PublicSuffixList()
    org_domain = psl.get_public_suffix(domain, strict=True)
    return(org_domain)

def is_public_hostname(hostname):
    ##  TODO: check for NS?
    psl = PublicSuffixList()
    if psl.get_public_suffix(hostname, strict=True):
        return True
    else:
        return False

def is_valid_tinysvg(svg):
    return true

def gunzip(bytes):
    if bytes[:2] == b'\x1f\x8b':
        return(gzip.decompress(bytes))
    else:
        return(bytes)

def get_tiny_svg(domain,selector,url):
    if not url.startswith("https://"):
        return(False)
    cache_file = args.cache_dir + "/bimi_" + domain + "_" + selector + ".svg"
    if Path(cache_file).is_file():
        with open(cache_file, 'rb') as file:
            downloaded_svg = file.read()
            file.close()
    else:
        r = requests.get(url, timeout=10, verify=True)
        downloaded_svg = gunzip(r.content)
        if len(downloaded_svg) > 32768:
            return(False)
        with open(cache_file, 'wb') as file:
            file.write(downloaded_svg)
            file.close()
    return(downloaded_svg)

def tag_value(tagval_string):
    ## Turn DKIM-style TXT records into dict
    txt_config = tagval_string.decode("utf-8").split(";")
    txt_config = [item for item in txt_config if "=" in item]
    d = dict(bytes(value,'utf-8').strip().split(b'=',1) for value in txt_config)
    d = { k.decode("utf-8") : v.decode("utf-8") for k,v in d.items() }
    return(d)

def dmarc_policy(domain):
    if not is_public_hostname(domain):
        logging.debug('DNS: %s not in publicsuffixlist',domain)
        return(False)
    try:
        if versiontuple(version('dnspython')) < versiontuple("2.0.0"):
            answers = dns.resolver.query('_dmarc.' + domain, 'TXT', raise_on_no_answer=False)
        else:
            answers = dns.resolver.resolve('_dmarc.' + domain, 'TXT', raise_on_no_answer=False)
        for rdata in answers:
            for txt_string in rdata.strings:
                if txt_string.decode("utf-8").startswith("v=DMARC1"):
                    d = tag_value(txt_string)
                    if not "pct" in d:
                        d["pct"] = "100"
                    if not "sp" in d:
                        d["sp"] = d.get("p")
                    return(d)
    except (dns.resolver.NXDOMAIN, dns.resolver.NoNameservers, dns.resolver.Timeout) as e:
        logging.debug('DMARC: DNS error requesting _dmarc.%s',domain)
        return(False)

    return(False)

def bimi_assert(domain,selector):
    org_domain = get_org_domain(domain)
    try:
        if versiontuple(version('dnspython')) < versiontuple("2.0.0"):
            answers = dns.resolver.query(selector + '._bimi.' + domain, 'TXT', raise_on_no_answer=False)
        else:
            answers = dns.resolver.resolve(selector + '._bimi.' + domain, 'TXT', raise_on_no_answer=False)
        for rdata in answers:
            for txt_string in rdata.strings:
                if txt_string.decode("utf-8").startswith("v=BIMI1"):
                    d = tag_value(txt_string)
                    if not "a" in d:
                        d["a"] = ""
                    if not "l" in d:
                        d["l"] = ""
                    return(d)
        if org_domain.casefold() == domain.casefold():
            logging.debug('BIMI: No record for %s',selector + '._bimi.' + domain)
            return(False)
        else:
            logging.debug('BIMI: No record for %s',selector + '._bimi.' + domain)
            return(bimi_assert(org_domain,selector))
    except (dns.resolver.NXDOMAIN, dns.resolver.NoNameservers, dns.resolver.Timeout) as e:
        if org_domain.casefold() != domain.casefold():
            logging.debug('BIMI:DNS error for %s',selector + '._bimi.' + domain)
            return(bimi_assert(org_domain,selector))
    return(False)

def qualifying_policy(domain):
    org_domain = get_org_domain(domain)
    policy = dmarc_policy(domain)
    if policy:
        if policy.get("p") not in ["none"]:
            if policy.get("sp") not in ["none"]:
                if policy.get("p") in ["quarantine"]:
                    if policy.get("pct") not in ["100"]:
                        logging.debug('DMARC: pct=%s',policy.get("pct"))
                        return(False)
                if org_domain.casefold() == domain.casefold():
                    return(True)
            else:
                logging.debug('DMARC: sp=none for %s', domain)
                return(False)
        else:
            logging.debug('DMARC: p=none for %s', domain)
            return(False)
    else:
        if org_domain.casefold() != domain.casefold():
            if qualifying_policy(org_domain):
                return(True)
    if org_domain.casefold() != domain.casefold():
        if qualifying_policy(org_domain):
            return(True)
    logging.debug('DMARC: no record for _dmarc.%s', domain)
    return(False)

def wrap_header(label,data,wrap):
    if wrap == "none":
        return(data)
    if label == "BIMI-Indicator: ":
        data = b64_wrap(label,data)
    else:
        data = Header(data,maxlinelen=78,header_name=label).encode()
    if wrap == "tab":
        data = tab_lines(data)
    return(data)

def b64_wrap(label,b64_str):
    ## mail tools don't know how to wrap a raw b64 blob
    data = '\n'.join(textwrap.wrap(label + b64_str, width=77, initial_indent='', subsequent_indent=' '))
    data = data[len(label):]
    return(data)

def tab_lines(headers):
    out = ''
    sp = iter(headers.splitlines())
    if sp == '':
        return(x)
    for x in sp:
        if x[0] == " ":
            out = out + "\t" + x[1:] + "\n"
        else:
            out = out + x + "\n"
    return out[:-1]

bimi_result=""
bimi_comment=""
policy_authority="none"
tinysvg=False
bimi_indicator=False
bimi_location=False
indicator_hash=False
b=False

if not qualifying_policy(args.domain):
    bimi_result = "skipped"
    bimi_comment = " (DMARC requirements unmet)"
else:
    b = bimi_assert(args.domain,args.selector)
    if not b:
        bimi_result = "none"
        if args.location_only:
            sys.exit(1)
    else:
        bimi_location = wrap_header("BIMI-Location: ","v=BIMI1; l=" + b.get("l") + "; a=" + b.get("a"),args.wrap)
        if args.location_only:
            print(bimi_location)
            sys.exit(0)
        if len(b.get("l")) == 0:
            bimi_result = "declined"
        else:
            tinysvg = get_tiny_svg(args.domain,args.selector,b.get("l"))
            if not tinysvg:
                bimi_result = "fail"
                bimi_comment = " (problem downloading logo)"
            else:
                bimi_result = "pass"
                bimi_indicator = wrap_header("BIMI-Indicator: ",base64.b64encode(tinysvg).decode('utf-8'),args.wrap)
                indicator_hash=hashlib.sha256(tinysvg).hexdigest()[-8:]

if args.status_only:
    print(bimi_result)
    sys.exit(0)

if args.indicator_only:
    if not tinysvg:
        sys.exit(1)
    else:
        print(bimi_indicator)
        sys.exit(0)

auth_results = "; bimi=" + bimi_result + bimi_comment + " header.d=" + args.domain
if not bimi_result == "skipped":
    auth_results = auth_results + " header.selector=" + args.selector
if tinysvg:
    auth_results = auth_results + " policy.authority=" + policy_authority
    auth_results = auth_results + " policy.indicator-hash=" + indicator_hash

if args.bimi_auth_only:
    print(auth_results)
    sys.exit(0)

auth_results_full = wrap_header("Authentication-Results: ",args.authserv_id + auth_results,args.wrap)

if bimi_indicator:
    print("BIMI-Indicator: " + bimi_indicator)
if bimi_location:
    print("BIMI-Location: " + bimi_location)
print("Authentication-Results: " + auth_results_full)
sys.exit(0)
